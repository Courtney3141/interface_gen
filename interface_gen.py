#!/usr/bin/python3
from interface_parse import Interface, ArgDirection

class InterfaceGen:
    preamble = '''
    /* This file is automatically generated, DO NOT EDIT */
    '''
    def __str__(self):

        return str(self.__class__) + ": " + str(self.__dict__)

    def __init__(self, interface, filebasename , wordsize):

        self.interface = interface
        self.filebasename = filebasename
        self.wordsize = wordsize

    def formatarg(self,a):
        if a.const =='true':
            const = 'const '
        else:
            const=''
        if a.direction == ArgDirection.IN:
            return f'{const}{a.ctype} {a.name}'
        else:
            return f'{a.ctype} *{a.name}'



    def ipc_in_struct_name(self,method):
        return f'{method}_ipc_in'

    def ipc_out_struct_name(self,method):
        return f'{method}_ipc_out'

    def gen_ipc_in_struct(self,method, args, indent=''):
        buf=''
        buf=buf+f'{indent}struct {self.ipc_in_struct_name(method)} {{'+'\n'
        for a in args:
            if a.direction != ArgDirection.OUT:
                if a.const =='true':
                    const = 'const '
                else:
                    const=''
                buf=buf+f'{indent}    {const}{a.ctype} {a.name};'+'\n'
        buf=buf+f'{indent}}};'+'\n'
        return buf

    def gen_ipc_out_struct(self,method, indent=''):
        buf=''
        buf=buf+f'{indent}struct {self.ipc_out_struct_name(method.name)} {{'+'\n'
        if method.return_type != 'void':
            buf=buf+f'{indent}    {method.return_type} __ret;'+'\n'
            for a in method.args:
                if a.direction != ArgDirection.IN:
                    buf=buf+f'{indent}    {a.ctype} {a.name};'+'\n'
        buf=buf+f'{indent}}};'+'\n'
        return buf




        
class InterfacePrint(InterfaceGen):
    def __str__(self):

        return str(self.__class__) + ": " + str(self.__dict__)

    def __init__(self, interface, filebasename = '', wordsize=8):

        super().__init__(interface, filebasename, wordsize)
        
        for i in self.interface.includes:
            print(f'#include {i.header}')

        for i in self.interface.defines:
            print(f'#define {i.name} ({i.value})')

        for i in self.interface.methods:
            print(f'{i.name}[id={i.id}](',end='')
            print(', '.join(map(self.formatarg,i.args)),end='')
            print(f') -> {i.return_type}')

class InterfaceClientStubs(InterfaceGen):
    def __str__(self):

        return str(self.__class__) + ": " + str(self.__dict__)

    def __init__(self, interface, filebasename = '', wordsize=8):

        super().__init__(interface, filebasename, wordsize)

        with open(self.filebasename + '.h', 'w') as hf:
            print(self.preamble, file=hf)
            
            for i in self.interface.includes:
                print(f'#include {i.header}',file=hf)

            for i in self.interface.defines:
                print(f'#define {i.name} ({i.value})', file=hf)

            for i in self.interface.methods:
                print(f'#define METHOD_NUM_{i.name.upper()} {i.id}',file=hf)
                print(f'extern {i.return_type} {i.name}(',end='', file=hf)

                    
                if len(i.args) != 0:
                    print(', '.join(map(self.formatarg,i.args)),end='',file=hf)
                else:
                    print(f'void',end='', file=hf)
                        
                
                print(');\n',file=hf)
            
            
        with open(self.filebasename + '.c', 'w') as cf:
            print(self.preamble, file=cf)
            print(f'#include <{self.filebasename + ".h"}>',file=cf)

            for i in self.interface.includes:
                print(f'#include {i.header}',file=cf)


            for i in self.interface.methods:
                print(f'{i.return_type} {i.name}(',end='', file=cf)
                
                if len(i.args) != 0:
                    print(', '.join(map(self.formatarg,i.args)),end='',file=cf)
                else:
                    print(f'void',end='', file=cf)

                
                print(')\n{',file=cf)
                print(self.gen_ipc_in_struct(i.name,i.args,'    '),file=cf)
                print(self.gen_ipc_out_struct(i,'    '),file=cf)
                print(f'    seL4_MessageInfo_t message;', file=cf)
                print(f'    seL4_IPCBuffer *ipc_buf = seL4_GetIPCBuffer();', file=cf)
                print(f'    struct {self.ipc_in_struct_name(i.name)} *argsin_ptr = (struct {self.ipc_in_struct_name(i.name)} *) &(ipc_buf->msg[0]);', file=cf)
                print(f'    struct {self.ipc_out_struct_name(i.name)} *argsout_ptr = (struct {self.ipc_out_struct_name(i.name)} *) &(ipc_buf->msg[0]);', file=cf)
                print(f'    *argsin_ptr = ((struct {self.ipc_in_struct_name(i.name)}) {{', end='', file=cf)
                initialiser = ', '.join(map(lambda a: f'{a.name}' if a.direction == ArgDirection.IN else f'*{a.name}',filter(lambda a: a.direction != ArgDirection.OUT, i.args)))
                print(initialiser, end='',file=cf)
                print('});',file=cf)
                print(f'    message = seL4_MessageInfo_new(METHOD_NUM_{i.name.upper()}, 0, 0, (sizeof(struct {self.ipc_in_struct_name(i.name)}) + {self.wordsize -1 })/{self.wordsize});', file=cf)
                print(f'    seL4_Call({i.cap}, message);',file=cf)
                outs = [a for a in i.args if a.direction != ArgDirection.IN]
                for o in outs:
                    print (f'    *{o.name} = argsout_ptr->{o.name};',file=cf)
                if i.return_type != 'void':
                    print(f'    return argsout_ptr->__ret;', file=cf)
                print('}\n\n',file=cf)
